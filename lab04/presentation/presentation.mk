# ===================================================================
# ЛАБОРАТОРНАЯ РАБОТА №4 - АЛГОРИТМ ЕВКЛИДА
# ===================================================================

# Название работы: Алгоритм Евклида
# Студент: Хамза Хуссен
# ===================================================================
# 1. ВВЕДЕНИЕ: ЦЕЛИ И ЗАДАЧИ ИССЛЕДОВАНИЯ
# ===================================================================

# Основная цель работы — ознакомиться с классическим алгоритмом Евклида
# для вычисления наибольшего общего делителя (НОД), а также изучить его
# модификации: бинарный и расширенный варианты.

# ===================================================================
# 2. ТЕОРЕТИЧЕСКАЯ ЧАСТЬ
# ===================================================================

# 2.1 ПОНЯТИЕ НАИБОЛЬШЕГО ОБЩЕГО ДЕЛИТЕЛЯ (НОД)
#
# Наибольшим общим делителем двух целых чисел называется наибольшее
# натуральное число, которое делит оба числа без остатка.
# 
# НОД играет важную роль в:
#   - Теории чисел
#   - Криптографии
#   - Алгоритмизации

# ===================================================================
# 2.2 КЛАССИЧЕСКИЙ АЛГОРИТМ ЕВКЛИДА
# ===================================================================

# Алгоритм основан на равенстве:
#   НОД(a, b) = НОД(b, a mod b), где a ≥ b > 0
#
# Этапы алгоритма:
#   1. Пусть r₀ = a, r₁ = b, i = 1
#   2. Найти остаток rᵢ₊₁ = rᵢ₋₁ mod rᵢ
#   3. Если rᵢ₊₁ = 0, то НОД = rᵢ
#   4. Иначе увеличить i на 1 и вернуться к шагу 2
#
# Пример: НОД(30, 18)
#   30 ÷ 18 = 1 (остаток 12)
#   18 ÷ 12 = 1 (остаток 6)
#   12 ÷ 6 = 2 (остаток 0)
#   НОД = 6

# ===================================================================
# 2.3 БИНАРНЫЙ АЛГОРИТМ ЕВКЛИДА
# ===================================================================

# Эта оптимизированная версия использует двоичное представление чисел
# и заменяет деление операциями сдвига.
#
# Основные принципы:
#   • Если оба числа чётные → НОД содержит множитель 2
#   • Если одно число чётное → делим на 2
#   • Если оба нечётные → выполняем вычитание
#
# Алгоритм:
#   1. Инициализировать множитель g = 1
#   2. Пока a и b чётные:
#        a = a / 2, b = b / 2, g = g * 2
#   3. u = a, v = b
#   4. Пока u ≠ 0:
#        • Делить u и v на 2, пока они чётные
#        • Если u ≥ v: u = u - v
#          Иначе: v = v - u
#   5. Результат: d = g * v

# ===================================================================
# 2.4 РАСШИРЕННЫЙ АЛГОРИТМ ЕВКЛИДА
# ===================================================================

# Позволяет найти коэффициенты x и y для представления:
#   a·x + b·y = НОД(a, b)
#
# Применение:
#   • Решение диофантовых уравнений
#   • Модульная арифметика
#
# Этапы алгоритма:
#   1. Инициализация:
#        r₀ = a, r₁ = b
#        x₀ = 1, x₁ = 0
#        y₀ = 0, y₁ = 1
#        i = 1
#   2. Найти qᵢ и rᵢ₊₁ от деления rᵢ₋₁ на rᵢ
#   3. Если rᵢ₊₁ = 0: результат d = rᵢ, x = xᵢ, y = yᵢ
#   4. Иначе:
#        xᵢ₊₁ = xᵢ₋₁ - qᵢ·xᵢ
#        yᵢ₊₁ = yᵢ₋₁ - qᵢ·yᵢ
#        увеличить i и вернуться к шагу 2

# ===================================================================
# 3. ВЫПОЛНЕНИЕ РАБОТЫ
# ===================================================================

# 3.1 РЕАЛИЗАЦИЯ АЛГОРИТМОВ НА PYTHON

define PYTHON_CODE
def euklid_simply(a, b):
    while a != 0 and b != 0:
        if a >= b:
            a = a % b
        else:
            b = b % a
    return a or b

def euklid_extended(a, b):
    if a == 0:
        return (b, 0, 1)
    else:
        div, x, y = euklid_extended(b % a, a)
    return (div, y - (b // a) * x, x)

def euklid_binary(a, b):
    g = 1
    while a % 2 == 0 and b % 2 == 0:
        a = a // 2
        b = b // 2
        g = g * 2
    u, v = a, b
    while u != 0:
        if u % 2 == 0:
            u = u // 2
        if v % 2 == 0:
            v = v // 2
        if u >= v:
            u = u - v
        else:
            v = v - u
    d = g * v
    return d

def euklid_bin_extended(a, b):
    g = 1
    while a % 2 == 0 and b % 2 == 0:
        a = a // 2
        b = b // 2
        g = g * 2
    u = a
    v = b
    A = 1
    B = 0
    C = 0
    D = 1
    while u != 0:
        if u % 2 == 0:
            u = u // 2
            if A % 2 == 0 and B % 2 == 0:
                A = A // 2
                B = B // 2
            else:
                A = (A + b) // 2
                B = (B - a) // 2
        if v % 2 == 0:
            v = v // 2
            if C % 2 == 0 and D % 2 == 0:
                C = C // 2
                D = D // 2
            else:
                C = (C + b) // 2
                D = (D - a) // 2
        if u >= v:
            u = u - v
            A = A - C
            B = B - D
        else:
            v = v - u
            C = C - A
            D = D - B
    d = g * v
    x = C
    y = D
    return (d, x, y)
endef

# ===================================================================
# 4. ПРАКТИЧЕСКАЯ ЧАСТЬ
# ===================================================================

# Реализации алгоритмов и результаты тестирования представлены
# в Python коде выше.

# ===================================================================
# 5. ЗАКЛЮЧЕНИЕ И ВЫВОДЫ
# ===================================================================

# В ходе выполнения лабораторной работы:
#   • Изучен классический алгоритм Евклида
#   • Рассмотрены бинарный и расширенный варианты
#   • Приведены примеры ручного вычисления
#   • Бинарный алгоритм более эффективен для программной реализации
#   • Расширенный алгоритм имеет важное применение в криптографии

# ===================================================================
# 6. СПИСОК ИСПОЛЬЗОВАННЫХ ИСТОЧНИКОВ
# ===================================================================

# 1. Введение в алгоритмы нахождения НОД
# 2. Модификации алгоритма Евклида: сравнительный анализ
# 3. Материалы лекций по теории чисел и алгоритмам
